/* Licensed under EPL-2.0 2024. */
package edu.kit.kastel.sdq.artemis4j.grading;

import java.util.Objects;
import java.util.Optional;
import java.util.UUID;

import edu.kit.kastel.sdq.artemis4j.client.AnnotationSource;
import edu.kit.kastel.sdq.artemis4j.grading.metajson.AnnotationDTO;
import edu.kit.kastel.sdq.artemis4j.grading.penalty.MistakeType;

/**
 * A single annotation as part of an assessment. Annotations may be manually
 * created, or generated by tools. Annotations may not be created for tests that
 * are executed by Artemis. Annotations must always be created via an active assessment's methods.
 */
public final class Annotation {
    private final String uuid;
    private final MistakeType type;
    private final String filePath;
    private final int startLine;
    private final int endLine;
    private final String customMessage;
    private final Double customScore;
    private final AnnotationSource source;

    /**
     * Deserializes an annotation from its metajson format
     *
     * @param dto
     * @param mistakeType
     */
    public Annotation(AnnotationDTO dto, MistakeType mistakeType) {
        this.uuid = dto.uuid();
        this.type = mistakeType;
        this.filePath = dto.classFilePath();
        this.startLine = dto.startLine();
        this.endLine = dto.endLine();
        this.customMessage = dto.customMessageForJSON();
        this.customScore = dto.customPenaltyForJSON();
        this.source = dto.source() != null ? dto.source() : AnnotationSource.UNKNOWN;
    }

    Annotation(MistakeType mistakeType, String filePath, int startLine, int endLine, String customMessage, Double customScore, AnnotationSource source) {
        // Validate custom penalty and message
        if (mistakeType.isCustomAnnotation()) {
            if (customScore == null) {
                throw new IllegalArgumentException("A custom penalty is required for custom annotation types.");
            }
            if (customMessage == null) {
                throw new IllegalArgumentException("A custom message is required for custom annotation types.");
            }
        } else if (customScore != null) {
            throw new IllegalArgumentException("A custom penalty is not allowed for non-custom annotation types.");
        }

        this.uuid = generateUUID();
        this.type = mistakeType;
        this.filePath = filePath;
        this.startLine = startLine;
        this.endLine = endLine;
        this.customMessage = customMessage;
        this.customScore = customScore;
        this.source = source;
    }

    /**
     * Uniquely identifies this annotation
     *
     * @return
     */
    public String getUUID() {
        return uuid;
    }

    public MistakeType getMistakeType() {
        return type;
    }

    /**
     * The path of the file this annotation is associated with, including its file ending
     *
     * @return
     */
    public String getFilePath() {
        return filePath;
    }

    /**
     * The path of the file this annotation is associated with, excluding its file ending
     *
     * @return
     */
    public String getFilePathWithoutType() {
        return this.filePath.replace(".java", "");
    }

    /**
     * The line in the file where this annotation starts (0-based)
     *
     * @return
     */
    public int getStartLine() {
        return startLine;
    }

    /**
     * The line in the file where this annotation starts (1-based, for display to the user e.g. in Artemis)
     *
     * @return
     */
    public int getDisplayLine() {
        return startLine + 1;
    }

    /**
     * The line in the file where this annotation ends (0-based)
     *
     * @return
     */
    public int getEndLine() {
        return endLine;
    }

    /**
     * The custom message associated with this message, if any. Is never empty for custom annotations.
     *
     * @return
     */
    public Optional<String> getCustomMessage() {
        return Optional.ofNullable(customMessage);
    }

    /**
     * The custom score associated with this message, if any. Is always empty for predefined annotations,
     * and never empty for custom annotations.
     *
     * @return
     */
    public Optional<Double> getCustomScore() {
        return Optional.ofNullable(customScore);
    }

    public AnnotationSource getSource() {
        return source;
    }

    /**
     * Serializes this annotation to its metajson format
     *
     * @return
     */
    public AnnotationDTO toDTO() {
        return new AnnotationDTO(uuid, type.getId(), startLine, endLine, filePath, customMessage, customScore, source);
    }

    @Override
    public boolean equals(Object o) {
        if (this == o)
            return true;
        if (o == null || getClass() != o.getClass())
            return false;
        Annotation that = (Annotation) o;
        return Objects.equals(uuid, that.uuid);
    }

    @Override
    public int hashCode() {
        return Objects.hashCode(uuid);
    }

    private static String generateUUID() {
        return UUID.randomUUID().toString();
    }
}
