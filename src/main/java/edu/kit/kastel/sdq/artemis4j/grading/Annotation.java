/* Licensed under EPL-2.0 2024-2025. */
package edu.kit.kastel.sdq.artemis4j.grading;

import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import java.util.UUID;

import edu.kit.kastel.sdq.artemis4j.client.AnnotationSource;
import edu.kit.kastel.sdq.artemis4j.grading.location.Location;
import edu.kit.kastel.sdq.artemis4j.grading.metajson.AnnotationDTO;
import edu.kit.kastel.sdq.artemis4j.grading.penalty.MistakeType;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * A single annotation as part of an assessment. Annotations may be manually
 * created, or generated by tools. Annotations may not be created for tests that
 * are executed by Artemis. Annotations must always be created via an active
 * assessment's methods.
 */
public final class Annotation {
    private static final Logger log = LoggerFactory.getLogger(Annotation.class);

    private final String uuid;
    private final MistakeType type;
    private final Location location;
    private final AnnotationSource source;
    private final Long createdByUserId; // null -> unknown creator
    private Long suppressedByUserId; // null -> not suppressed
    private String customMessage;
    private Double customScore;
    // If not empty, this list contains classifiers that are used to group annotations.
    // For example, all annotations that are related, could have the classifier ["a"],
    // then they would be grouped together.
    //
    // You can add further classifiers to group annotations in a more fine-grained way:
    // For example, when you have annotations with the classifiers ["a", "b"]
    // and ["a", "c"], then if there are more than "annotationLimit"
    // with the classifier "a", it would merge all annotations with the classifiers ["a", "b"]
    // and all annotations with the classifiers ["a", "c"].
    private final List<String> classifiers;
    private final Integer annotationLimit;

    /**
     * Deserializes an annotation from its metajson format
     */
    public Annotation(AnnotationDTO dto, MistakeType mistakeType) {
        this.uuid = dto.uuid();
        this.type = mistakeType;
        this.location = new Location(dto.classFilePath(), dto.start(), dto.end());
        this.source = dto.source() != null ? dto.source() : AnnotationSource.UNKNOWN;
        this.customMessage = dto.customMessageForJSON();
        this.customScore = dto.customPenaltyForJSON();
        this.classifiers = dto.classifiers() != null ? dto.classifiers() : List.of();
        this.annotationLimit = dto.annotationLimit();
        this.createdByUserId = dto.createdByUserId();
        this.suppressedByUserId = dto.suppressedByUserId();
    }

    Annotation(
            MistakeType mistakeType,
            Location location,
            String customMessage,
            Double customScore,
            AnnotationSource source,
            Long createdByUserId) {
        this(mistakeType, location, customMessage, customScore, source, createdByUserId, List.of(), null);
    }

    Annotation(
            MistakeType mistakeType,
            Location location,
            String customMessage,
            Double customScore,
            AnnotationSource source,
            Long createdByUserId,
            List<String> classifiers,
            Integer annotationLimit) {
        // Validate custom penalty and message
        if (mistakeType.isCustomAnnotation()) {
            if (customScore == null) {
                throw new IllegalArgumentException("A custom penalty is required for custom annotation types.");
            }
            if (customMessage == null) {
                throw new IllegalArgumentException("A custom message is required for custom annotation types.");
            }
        } else if (customScore != null) {
            throw new IllegalArgumentException("A custom penalty is not allowed for non-custom annotation types.");
        }

        if (createdByUserId == null) {
            log.warn("Creator user id is null, this annotation will not be associated with a user.");
        }

        this.uuid = generateUUID();
        this.type = mistakeType;
        this.location = location;
        this.customMessage = customMessage;
        this.customScore = customScore;
        this.source = source;
        this.createdByUserId = createdByUserId;
        this.suppressedByUserId = null; // Not suppressed
        this.classifiers = new ArrayList<>(classifiers);
        this.annotationLimit = annotationLimit;
    }

    /**
     * Uniquely identifies this annotation
     */
    public String getUUID() {
        return uuid;
    }

    public MistakeType getMistakeType() {
        return type;
    }

    /**
     * Returns the location of this annotation in the source code.
     */
    public Location getLocation() {
        return this.location;
    }

    /**
     * The path of the file this annotation is associated with, including its file
     * ending
     */
    public String getFilePath() {
        return this.getLocation().filePath();
    }

    /**
     * The path of the file this annotation is associated with, excluding its file
     * ending
     */
    public String getFilePathWithoutType() {
        return this.getFilePath().replace(".java", "");
    }

    /**
     * The line in the file where this annotation starts (0-based)
     */
    public int getStartLine() {
        return this.getLocation().start().line();
    }

    /**
     * The line in the file where this annotation starts (1-based, for display to
     * the user e.g. in Artemis)
     */
    public int getDisplayLine() {
        return this.getStartLine() + 1;
    }

    /**
     * The line in the file where this annotation ends (0-based)
     */
    public int getEndLine() {
        return this.getLocation().end().line();
    }

    /**
     * The custom message associated with this message, if any. Is never empty for
     * custom annotations.
     */
    public Optional<String> getCustomMessage() {
        return Optional.ofNullable(customMessage);
    }

    public void setCustomMessage(String message) {
        if (this.type.isCustomAnnotation() && message == null) {
            throw new IllegalArgumentException("A custom message is required for custom annotation types.");
        }
        if (this.isSuppressed()) {
            throw new ReviewException("Can't change the custom message of a suppressed annotation.");
        }

        this.customMessage = message;
    }

    /**
     * Returns the classifiers of this annotation that can be used to group annotations.
     *
     * @return a list of classifiers
     */
    public List<String> getClassifiers() {
        return new ArrayList<>(this.classifiers);
    }

    /**
     * Returns the maximum number of annotations that should be displayed if one or more classifiers match.
     * <p>
     * It is up to the implementation, how the limit is applied in case of multiple classifiers.
     *
     * @return the maximum number of annotations that should be displayed
     */
    public Optional<Integer> getAnnotationLimit() {
        return Optional.ofNullable(this.annotationLimit);
    }

    /**
     * The custom score associated with this message, if any. Is always empty for
     * predefined annotations, and never empty for custom annotations.
     */
    public Optional<Double> getCustomScore() {
        return Optional.ofNullable(customScore);
    }

    public void setCustomScore(Double score) {
        if (!this.type.isCustomAnnotation() && score != null) {
            throw new IllegalArgumentException("A custom score is not allowed for non-custom annotation types.");
        }
        if (this.type.isCustomAnnotation() && score == null) {
            throw new IllegalArgumentException("A custom score is required for custom annotation types.");
        }
        if (this.isSuppressed()) {
            throw new ReviewException("Can't change the custom score of a suppressed annotation.");
        }

        this.customScore = score;
    }

    public AnnotationSource getSource() {
        return source;
    }

    public Optional<Long> getCreatorId() {
        return Optional.ofNullable(createdByUserId);
    }

    public void suppress(long userId) {
        this.suppressedByUserId = userId;
    }

    public void unsuppress() {
        this.suppressedByUserId = null;
    }

    public boolean isSuppressed() {
        return this.suppressedByUserId != null;
    }

    public Optional<Long> getSuppressorId() {
        return Optional.ofNullable(suppressedByUserId);
    }

    /**
     * Serializes this annotation to its metajson format
     */
    public AnnotationDTO toDTO() {
        return new AnnotationDTO(
                uuid,
                type.getId(),
                getLocation().start(),
                getLocation().end(),
                getFilePath(),
                customMessage,
                customScore,
                source,
                classifiers,
                annotationLimit,
                createdByUserId,
                suppressedByUserId);
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Annotation that = (Annotation) o;
        return Objects.equals(uuid, that.uuid);
    }

    @Override
    public int hashCode() {
        return Objects.hashCode(uuid);
    }

    private static String generateUUID() {
        return UUID.randomUUID().toString();
    }
}
